from __future__ import annotations
import numpy as np
from treeswift import Tree, Node
from numpy import ndarray as Array
import matplotlib.pyplot as plt

from hypercube import Hypercube


class Quadtree(Tree):

    def __init__(self, points):
        super().__init__()
        self.M = np.max(np.abs(points))
        self.X = np.hstack((
            np.arange(points.shape[0]).reshape((-1, 1)),
            points / self.M,
        ))
        self.phi = np.max(self.X[:, 1:])
        bounds = np.zeros((points.shape[1], 2))
        bounds[:, 1] = self.phi
        self.root.add_child(QuadNode(Hypercube(bounds, self.X), np.log(self.phi)))

class QuadLeaf(Node):

    def __init__(self, x: np.ndarray, level: int) -> None:
        super().__init__(label=int(x[0]), edge_length=2**level)
        self.x = x[1:]
        self.level = level
    
    def __repr__(self) -> str:
        return str(self.label)

class QuadNode(Node):

    def __init__(self, hypercube: Hypercube, level: int) -> None:
        super().__init__(label=level, edge_length=2**level)
        self.level = level
        for child in hypercube.divide():
            if isinstance(child, Hypercube):
                self.add_child(QuadNode(child, level-1))
            else:
                self.add_child(QuadLeaf(child, level-1))
        # self.color = '#'
        # for _ in range(6):
        #     self.color += '0123456789abcdef'[np.random.randint(0, 16)]

class Distribution:

    def __init__(self, support: Array, weights: Array) -> None:
        self.support = support
        self.weights = weights

    def __repr__(self) -> str:
        repr = ''
        for i in range(6):
            repr += str(self.support[i]) + '\t'
        repr += '...\n'
        for i in range(6):
            repr += f"{self.weights[i]:.4f}\t"
        return repr + '...'

    @classmethod
    def uniform_distribution(cls, N: int, s: int) -> Distribution:
        support = np.arange(0, N, 1)
        np.random.shuffle(support)
        support = support[:s]
        weights = np.random.rand(s)
        return Distribution(support, weights)

    def plot(self, N: int):
        plt.bar(self.support, self.weights)
        plt.xlim(0, N)
        plt.show()    

def quadtree_wassertein(
    quadtree: Quadtree,
    mu: Distribution,
    nu: Distribution,
) -> float:
    pass